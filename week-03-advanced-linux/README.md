# Week 3: Advanced Linux & Automation

## ðŸŽ¯ Learning Objectives
By the end of this week, you will:
- Write effective shell scripts for automation
- Schedule tasks with cron and systemd timers
- Manage system services and daemons
- Analyze logs and troubleshoot system issues

---

## Day 1-2: Shell Scripting Fundamentals

### Why Shell Scripting?

Shell scripting automates repetitive tasks, making system administration efficient. Scripts can:
- **Automate backups** and maintenance tasks
- **Monitor systems** and send alerts
- **Deploy applications** and configurations
- **Process data** and generate reports

### Basic Script Structure

```bash
#!/bin/bash
# This is a comment
# The shebang line tells the system which interpreter to use

# Variables
NAME="World"
COUNT=5

# Output
echo "Hello, $NAME!"
echo "Count is: $COUNT"

# Command substitution
CURRENT_DATE=$(date)
echo "Today is: $CURRENT_DATE"
```

### Variables and Data Types

```bash
#!/bin/bash

# String variables
USERNAME="admin"
HOSTNAME=$(hostname)
MESSAGE='Single quotes preserve literal text'

# Numeric variables
NUMBER=42
RESULT=$((NUMBER * 2))  # Arithmetic expansion

# Arrays
FRUITS=("apple" "banana" "orange")
echo "First fruit: ${FRUITS[0]}"
echo "All fruits: ${FRUITS[@]}"

# Environment variables
echo "Home directory: $HOME"
echo "Current user: $USER"
echo "Path: $PATH"

# Special variables
echo "Script name: $0"
echo "First argument: $1"
echo "All arguments: $@"
echo "Number of arguments: $#"
echo "Exit status of last command: $?"
```

### Control Structures

```bash
#!/bin/bash

# If statements
if [ "$USER" = "root" ]; then
    echo "Running as root"
elif [ "$USER" = "admin" ]; then
    echo "Running as admin"
else
    echo "Running as regular user: $USER"
fi

# For loops
echo "Counting to 5:"
for i in {1..5}; do
    echo "Number: $i"
done

echo "Processing files:"
for file in *.txt; do
    if [ -f "$file" ]; then
        echo "Processing: $file"
    fi
done

# While loops
counter=1
while [ $counter -le 3 ]; do
    echo "Loop iteration: $counter"
    counter=$((counter + 1))
done

# Case statements
read -p "Enter a choice (a/b/c): " choice
case $choice in
    a|A)
        echo "You chose option A"
        ;;
    b|B)
        echo "You chose option B"
        ;;
    c|C)
        echo "You chose option C"
        ;;
    *)
        echo "Invalid choice"
        ;;
esac
```

### Functions and Error Handling

```bash
#!/bin/bash

# Function definition
backup_file() {
    local source_file="$1"
    local backup_dir="$2"
    
    if [ ! -f "$source_file" ]; then
        echo "Error: Source file '$source_file' not found" >&2
        return 1
    fi
    
    if [ ! -d "$backup_dir" ]; then
        mkdir -p "$backup_dir"
    fi
    
    cp "$source_file" "$backup_dir/$(basename "$source_file").$(date +%Y%m%d_%H%M%S)"
    echo "Backup created successfully"
    return 0
}

# Error handling with set options
set -e  # Exit on any error
set -u  # Exit on undefined variable
set -o pipefail  # Exit on pipe failure

# Function usage
if backup_file "/etc/passwd" "/tmp/backups"; then
    echo "Backup completed"
else
    echo "Backup failed"
    exit 1
fi
```

### ðŸ§ª Hands-On Exercise: Day 1-2

**Exercise 1: System Information Script**
```bash
# Create system_info.sh
cat > system_info.sh << 'EOF'
#!/bin/bash

# System Information Script
echo "=== System Information Report ==="
echo "Generated on: $(date)"
echo "Generated by: $USER"
echo ""

# System details
echo "=== System Details ==="
echo "Hostname: $(hostname)"
echo "Operating System: $(cat /etc/os-release | grep PRETTY_NAME | cut -d'"' -f2)"
echo "Kernel Version: $(uname -r)"
echo "Architecture: $(uname -m)"
echo "Uptime: $(uptime -p)"
echo ""

# Hardware information
echo "=== Hardware Information ==="
echo "CPU: $(lscpu | grep 'Model name' | cut -d':' -f2 | xargs)"
echo "Memory: $(free -h | grep Mem | awk '{print $2}')"
echo "Disk Usage:"
df -h | grep -E '^/dev/' | awk '{print "  " $1 ": " $3 "/" $2 " (" $5 " used)"}'
echo ""

# Network information
echo "=== Network Information ==="
echo "IP Addresses:"
ip addr show | grep 'inet ' | grep -v '127.0.0.1' | awk '{print "  " $NF ": " $2}'
echo ""

# Top processes
echo "=== Top 5 CPU Processes ==="
ps aux --sort=-%cpu | head -6 | tail -5 | awk '{print "  " $11 " (PID: " $2 ", CPU: " $3 "%)"}'
EOF

chmod +x system_info.sh
./system_info.sh
```

**Exercise 2: File Management Script**
```bash
# Create file_manager.sh
cat > file_manager.sh << 'EOF'
#!/bin/bash

# File Management Script with functions

# Function to create directory structure
create_project() {
    local project_name="$1"
    
    if [ -z "$project_name" ]; then
        echo "Usage: create_project <project_name>"
        return 1
    fi
    
    echo "Creating project structure for: $project_name"
    mkdir -p "$project_name"/{src,docs,tests,config}
    touch "$project_name"/README.md
    echo "# $project_name" > "$project_name"/README.md
    echo "Project structure created successfully!"
}

# Function to backup directory
backup_directory() {
    local source_dir="$1"
    local backup_base="${2:-/tmp/backups}"
    
    if [ ! -d "$source_dir" ]; then
        echo "Error: Directory '$source_dir' not found"
        return 1
    fi
    
    local backup_name="$(basename "$source_dir")_backup_$(date +%Y%m%d_%H%M%S)"
    local backup_path="$backup_base/$backup_name"
    
    mkdir -p "$backup_base"
    cp -r "$source_dir" "$backup_path"
    echo "Backup created: $backup_path"
}

# Function to clean old files
clean_old_files() {
    local directory="$1"
    local days="${2:-30}"
    
    if [ ! -d "$directory" ]; then
        echo "Error: Directory '$directory' not found"
        return 1
    fi
    
    echo "Finding files older than $days days in $directory..."
    find "$directory" -type f -mtime +$days -print
    
    read -p "Delete these files? (y/N): " confirm
    if [ "$confirm" = "y" ] || [ "$confirm" = "Y" ]; then
        find "$directory" -type f -mtime +$days -delete
        echo "Old files deleted"
    else
        echo "Operation cancelled"
    fi
}

# Main menu
while true; do
    echo ""
    echo "=== File Manager ==="
    echo "1. Create project structure"
    echo "2. Backup directory"
    echo "3. Clean old files"
    echo "4. Exit"
    read -p "Choose an option (1-4): " choice
    
    case $choice in
        1)
            read -p "Enter project name: " project
            create_project "$project"
            ;;
        2)
            read -p "Enter directory to backup: " dir
            backup_directory "$dir"
            ;;
        3)
            read -p "Enter directory to clean: " dir
            read -p "Enter days (default 30): " days
            clean_old_files "$dir" "${days:-30}"
            ;;
        4)
            echo "Goodbye!"
            break
            ;;
        *)
            echo "Invalid option"
            ;;
    esac
done
EOF

chmod +x file_manager.sh
./file_manager.sh
```

---

## Day 3-4: Task Automation with Cron and Systemd

### Understanding Cron

Cron is a time-based job scheduler that runs commands at specified intervals. It's perfect for:
- **System maintenance** tasks
- **Backup operations**
- **Log rotation**
- **Monitoring scripts**

### Cron Syntax

```bash
# Cron format: minute hour day month weekday command
# * * * * * command
# | | | | |
# | | | | +-- Day of week (0-7, Sunday = 0 or 7)
# | | | +---- Month (1-12)
# | | +------ Day of month (1-31)
# | +-------- Hour (0-23)
# +---------- Minute (0-59)

# Examples:
# 0 2 * * *     # Daily at 2:00 AM
# 30 14 * * 1   # Every Monday at 2:30 PM
# 0 */6 * * *   # Every 6 hours
# 15 10 1 * *   # First day of every month at 10:15 AM
# 0 9-17 * * 1-5 # Every hour from 9 AM to 5 PM, Monday to Friday
```

### Managing Cron Jobs

```bash
# View current user's cron jobs
crontab -l

# Edit current user's cron jobs
crontab -e

# Remove all cron jobs for current user
crontab -r

# Edit cron jobs for specific user (as root)
sudo crontab -u username -e

# System-wide cron directories
ls /etc/cron.d/      # System cron jobs
ls /etc/cron.daily/  # Daily scripts
ls /etc/cron.weekly/ # Weekly scripts
ls /etc/cron.monthly/ # Monthly scripts
```

### Systemd Timers (Modern Alternative)

Systemd timers are more powerful and flexible than cron:

```bash
# Create a service file
sudo tee /etc/systemd/system/backup.service << EOF
[Unit]
Description=Daily Backup Service
Wants=backup.timer

[Service]
Type=oneshot
ExecStart=/usr/local/bin/backup_script.sh

[Install]
WantedBy=multi-user.target
EOF

# Create a timer file
sudo tee /etc/systemd/system/backup.timer << EOF
[Unit]
Description=Run backup daily
Requires=backup.service

[Timer]
OnCalendar=daily
Persistent=true

[Install]
WantedBy=timers.target
EOF

# Enable and start the timer
sudo systemctl daemon-reload
sudo systemctl enable backup.timer
sudo systemctl start backup.timer

# Check timer status
sudo systemctl list-timers
sudo systemctl status backup.timer
```

### ðŸ§ª Hands-On Exercise: Day 3-4

**Exercise 1: Automated System Monitoring**
```bash
# Create monitoring script
sudo mkdir -p /usr/local/bin
sudo tee /usr/local/bin/system_monitor.sh << 'EOF'
#!/bin/bash

LOG_FILE="/var/log/system_monitor.log"
ALERT_EMAIL="admin@example.com"  # Change this to your email

# Function to log messages
log_message() {
    echo "$(date '+%Y-%m-%d %H:%M:%S') - $1" >> "$LOG_FILE"
}

# Check disk usage
check_disk_usage() {
    local threshold=80
    
    df -h | grep -E '^/dev/' | while read filesystem size used avail percent mountpoint; do
        usage=$(echo $percent | sed 's/%//')
        if [ $usage -gt $threshold ]; then
            message="ALERT: Disk usage on $mountpoint is ${percent} (threshold: ${threshold}%)"
            log_message "$message"
            echo "$message"
        fi
    done
}

# Check memory usage
check_memory_usage() {
    local threshold=80
    
    memory_usage=$(free | grep Mem | awk '{printf "%.0f", $3/$2 * 100}')
    if [ $memory_usage -gt $threshold ]; then
        message="ALERT: Memory usage is ${memory_usage}% (threshold: ${threshold}%)"
        log_message "$message"
        echo "$message"
    fi
}

# Check system load
check_system_load() {
    local threshold=2.0
    
    load_avg=$(uptime | awk -F'load average:' '{print $2}' | awk '{print $1}' | sed 's/,//')
    if (( $(echo "$load_avg > $threshold" | bc -l) )); then
        message="ALERT: System load is $load_avg (threshold: $threshold)"
        log_message "$message"
        echo "$message"
    fi
}

# Main monitoring function
main() {
    log_message "Starting system monitoring check"
    
    check_disk_usage
    check_memory_usage
    check_system_load
    
    log_message "System monitoring check completed"
}

# Run main function
main
EOF

sudo chmod +x /usr/local/bin/system_monitor.sh

# Test the script
sudo /usr/local/bin/system_monitor.sh

# Add to cron (run every 15 minutes)
echo "*/15 * * * * /usr/local/bin/system_monitor.sh" | sudo crontab -
```

**Exercise 2: Automated Backup System**
```bash
# Create backup script
sudo tee /usr/local/bin/backup_system.sh << 'EOF'
#!/bin/bash

BACKUP_DIR="/backup"
SOURCE_DIRS=("/etc" "/home" "/var/log")
RETENTION_DAYS=7
LOG_FILE="/var/log/backup.log"

# Function to log messages
log_message() {
    echo "$(date '+%Y-%m-%d %H:%M:%S') - $1" | tee -a "$LOG_FILE"
}

# Create backup directory
mkdir -p "$BACKUP_DIR"

# Start backup
log_message "Starting backup process"

for source in "${SOURCE_DIRS[@]}"; do
    if [ -d "$source" ]; then
        backup_name="$(basename "$source")_$(date +%Y%m%d_%H%M%S).tar.gz"
        backup_path="$BACKUP_DIR/$backup_name"
        
        log_message "Backing up $source to $backup_path"
        
        if tar -czf "$backup_path" "$source" 2>/dev/null; then
            log_message "Successfully backed up $source"
        else
            log_message "ERROR: Failed to backup $source"
        fi
    else
        log_message "WARNING: Source directory $source not found"
    fi
done

# Clean old backups
log_message "Cleaning backups older than $RETENTION_DAYS days"
find "$BACKUP_DIR" -name "*.tar.gz" -mtime +$RETENTION_DAYS -delete

log_message "Backup process completed"

# Show backup directory size
backup_size=$(du -sh "$BACKUP_DIR" | cut -f1)
log_message "Total backup size: $backup_size"
EOF

sudo chmod +x /usr/local/bin/backup_system.sh

# Test the backup script
sudo /usr/local/bin/backup_system.sh

# Schedule daily backup at 2 AM
echo "0 2 * * * /usr/local/bin/backup_system.sh" | sudo crontab -
```

---

## Day 5-7: System Services & Log Management

### Understanding System Services

System services (daemons) are background processes that provide system functionality:
- **Web servers** (Apache, Nginx)
- **Database servers** (MySQL, PostgreSQL)
- **SSH daemon** (sshd)
- **Network services** (NetworkManager, systemd-networkd)

### Systemd Service Management

```bash
# Service status and control
sudo systemctl status service_name    # Check service status
sudo systemctl start service_name     # Start service
sudo systemctl stop service_name      # Stop service
sudo systemctl restart service_name   # Restart service
sudo systemctl reload service_name    # Reload configuration

# Service enablement (auto-start)
sudo systemctl enable service_name    # Enable auto-start
sudo systemctl disable service_name   # Disable auto-start
sudo systemctl is-enabled service_name # Check if enabled

# List services
systemctl list-units --type=service   # List all services
systemctl list-units --type=service --state=running  # Running services
systemctl list-units --type=service --state=failed   # Failed services
```

### Creating Custom Services

```bash
# Create a custom service file
sudo tee /etc/systemd/system/myapp.service << EOF
[Unit]
Description=My Application Service
After=network.target

[Service]
Type=simple
User=myuser
WorkingDirectory=/opt/myapp
ExecStart=/opt/myapp/start.sh
ExecReload=/bin/kill -HUP \$MAINPID
Restart=always
RestartSec=10

[Install]
WantedBy=multi-user.target
EOF

# Reload systemd and start service
sudo systemctl daemon-reload
sudo systemctl enable myapp.service
sudo systemctl start myapp.service
```

### Log Management with journalctl

```bash
# View system logs
journalctl                           # All logs
journalctl -f                        # Follow logs (like tail -f)
journalctl -u service_name           # Logs for specific service
journalctl -u service_name -f        # Follow service logs

# Time-based filtering
journalctl --since "2024-01-01"     # Since specific date
journalctl --since "1 hour ago"     # Since 1 hour ago
journalctl --since today            # Since today
journalctl --until "2024-01-01"     # Until specific date

# Priority filtering
journalctl -p err                    # Error messages only
journalctl -p warning               # Warning and above
journalctl -p info                  # Info and above

# Output formatting
journalctl -o json                  # JSON format
journalctl -o json-pretty           # Pretty JSON
journalctl --no-pager               # Don't use pager
```

### Traditional Log Files

```bash
# Important log locations
/var/log/syslog          # System messages (Debian/Ubuntu)
/var/log/messages        # System messages (CentOS/RHEL)
/var/log/auth.log        # Authentication logs
/var/log/kern.log        # Kernel messages
/var/log/cron.log        # Cron job logs
/var/log/apache2/        # Apache web server logs
/var/log/nginx/          # Nginx web server logs

# Log analysis commands
tail -f /var/log/syslog              # Follow system log
grep "error" /var/log/syslog         # Find errors
awk '/error/ {print $1, $2, $3}' /var/log/syslog  # Extract timestamp of errors
```

### ðŸ§ª Hands-On Exercise: Day 5-7

**Exercise 1: Custom Service Creation**
```bash
# Create a simple web server script
sudo mkdir -p /opt/simple-web
sudo tee /opt/simple-web/server.py << 'EOF'
#!/usr/bin/env python3
import http.server
import socketserver
import os

PORT = 8080
os.chdir('/opt/simple-web')

Handler = http.server.SimpleHTTPRequestHandler
with socketserver.TCPServer(("", PORT), Handler) as httpd:
    print(f"Server running on port {PORT}")
    httpd.serve_forever()
EOF

# Create index.html
sudo tee /opt/simple-web/index.html << 'EOF'
<!DOCTYPE html>
<html>
<head>
    <title>Simple Web Server</title>
</head>
<body>
    <h1>Hello from Custom Service!</h1>
    <p>This page is served by a custom systemd service.</p>
    <p>Current time: <span id="time"></span></p>
    <script>
        document.getElementById('time').textContent = new Date().toLocaleString();
    </script>
</body>
</html>
EOF

sudo chmod +x /opt/simple-web/server.py

# Create systemd service
sudo tee /etc/systemd/system/simple-web.service << 'EOF'
[Unit]
Description=Simple Web Server
After=network.target

[Service]
Type=simple
User=nobody
WorkingDirectory=/opt/simple-web
ExecStart=/usr/bin/python3 /opt/simple-web/server.py
Restart=always
RestartSec=5

[Install]
WantedBy=multi-user.target
EOF

# Enable and start the service
sudo systemctl daemon-reload
sudo systemctl enable simple-web.service
sudo systemctl start simple-web.service

# Check service status
sudo systemctl status simple-web.service

# Test the web server
curl http://localhost:8080
```

**Exercise 2: Log Analysis Script**
```bash
# Create log analysis script
cat > log_analyzer.sh << 'EOF'
#!/bin/bash

LOG_FILE="${1:-/var/log/syslog}"
REPORT_FILE="/tmp/log_analysis_$(date +%Y%m%d_%H%M%S).txt"

if [ ! -f "$LOG_FILE" ]; then
    echo "Error: Log file '$LOG_FILE' not found"
    exit 1
fi

echo "=== Log Analysis Report ===" > "$REPORT_FILE"
echo "Log file: $LOG_FILE" >> "$REPORT_FILE"
echo "Analysis date: $(date)" >> "$REPORT_FILE"
echo "" >> "$REPORT_FILE"

# Basic statistics
echo "=== Basic Statistics ===" >> "$REPORT_FILE"
echo "Total lines: $(wc -l < "$LOG_FILE")" >> "$REPORT_FILE"
echo "File size: $(du -h "$LOG_FILE" | cut -f1)" >> "$REPORT_FILE"
echo "" >> "$REPORT_FILE"

# Error analysis
echo "=== Error Analysis ===" >> "$REPORT_FILE"
error_count=$(grep -i "error" "$LOG_FILE" | wc -l)
echo "Total errors: $error_count" >> "$REPORT_FILE"

if [ $error_count -gt 0 ]; then
    echo "Recent errors (last 10):" >> "$REPORT_FILE"
    grep -i "error" "$LOG_FILE" | tail -10 >> "$REPORT_FILE"
fi
echo "" >> "$REPORT_FILE"

# Warning analysis
echo "=== Warning Analysis ===" >> "$REPORT_FILE"
warning_count=$(grep -i "warning\|warn" "$LOG_FILE" | wc -l)
echo "Total warnings: $warning_count" >> "$REPORT_FILE"

if [ $warning_count -gt 0 ]; then
    echo "Recent warnings (last 5):" >> "$REPORT_FILE"
    grep -i "warning\|warn" "$LOG_FILE" | tail -5 >> "$REPORT_FILE"
fi
echo "" >> "$REPORT_FILE"

# Top processes/services
echo "=== Top Active Services ===" >> "$REPORT_FILE"
awk '{print $5}' "$LOG_FILE" | grep -v "^$" | sort | uniq -c | sort -nr | head -10 >> "$REPORT_FILE"
echo "" >> "$REPORT_FILE"

# Hourly activity
echo "=== Hourly Activity ===" >> "$REPORT_FILE"
awk '{print $3}' "$LOG_FILE" | cut -d: -f1 | sort | uniq -c | sort -k2 -n >> "$REPORT_FILE"

echo "Analysis complete. Report saved to: $REPORT_FILE"
cat "$REPORT_FILE"
EOF

chmod +x log_analyzer.sh

# Run log analysis
./log_analyzer.sh

# If you have access to auth.log, analyze authentication attempts
if [ -f /var/log/auth.log ]; then
    ./log_analyzer.sh /var/log/auth.log
fi
```

---

## ðŸŽ¯ Week 3 Summary & Assessment

### Skills Mastered
- âœ… **Shell Scripting** - Write automation scripts with functions and error handling
- âœ… **Task Scheduling** - Use cron and systemd timers for automation
- âœ… **Service Management** - Control and create system services
- âœ… **Log Analysis** - Monitor and analyze system logs
- âœ… **System Automation** - Implement monitoring and backup solutions

### Key Commands Reference
```bash
# Shell Scripting
bash, sh, chmod, source, export

# Cron Management
crontab -l, crontab -e, crontab -r

# Systemd Services
systemctl start/stop/restart/status/enable/disable
journalctl -u service_name -f

# Log Analysis
tail, grep, awk, sed, sort, uniq, wc
```

### Practice Challenges

**Challenge 1: Complete Monitoring Solution**
Create a comprehensive monitoring system that:
- Monitors system resources (CPU, memory, disk)
- Checks service availability
- Sends alerts when thresholds are exceeded
- Generates daily reports

**Challenge 2: Automated Deployment Script**
Build a deployment script that:
- Downloads application code from Git
- Installs dependencies
- Configures services
- Performs health checks
- Rolls back on failure

**Challenge 3: Log Rotation and Analysis**
Implement:
- Custom log rotation policies
- Automated log analysis and alerting
- Log archival and cleanup
- Performance trend analysis

### Next Steps
You're ready for **Week 4: AWS Fundamentals** where you'll learn:
- AWS account setup and IAM
- Core AWS services (EC2, VPC, S3)
- AWS CLI and automation
- Cloud architecture basics

---

## ðŸ“š Additional Resources

### Documentation
- [Bash Scripting Guide](https://tldp.org/LDP/Bash-Beginners-Guide/html/)
- [Systemd Documentation](https://www.freedesktop.org/software/systemd/man/)
- [Cron Tutorial](https://crontab.guru/)

### Practice Platforms
- [HackerRank Shell Scripting](https://www.hackerrank.com/domains/shell)
- [Bash Academy](https://guide.bash.academy/)
- [Linux Shell Scripting Tutorial](https://bash.cyberciti.biz/guide/Main_Page)

**Ready for Week 4?** Continue to [Week 4: AWS Fundamentals](../week-04-aws-fundamentals/README.md)
